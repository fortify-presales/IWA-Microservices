name: Changed Services Detector

on:
  push:
    branches: [ main, develop, feature/**, hotfix/** ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read

env:
  SERVICES_DIRS: "apps gateway services"

jobs:
  detect:
    name: Detect changed services
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determine changed files
      id: changes
      run: |
        echo "GITHUB_EVENT_NAME=${GITHUB_EVENT_NAME}"
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "PR detected"
          git fetch origin +refs/heads/${{ github.base_ref }}:refs/remotes/origin/${{ github.base_ref }}
          BASE=${{ github.event.pull_request.base.sha }}
          HEAD=${{ github.event.pull_request.head.sha }}
        else
          BASE=${{ github.event.before }}
          HEAD=${{ github.sha }}
        fi
        echo "Base=$BASE"; echo "Head=$HEAD"
        git diff --name-only $BASE $HEAD > changed_files.txt || true
        echo "Changed files:"; cat changed_files.txt
        # export the changed files as a multiline step output
        echo "files<<EOF" >> $GITHUB_OUTPUT
        cat changed_files.txt >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Build matrix of changed services
      id: set-matrix
      run: |
        files=$(cat changed_files.txt || true)
        echo "Parsing changed files..."
        services=()

        # map changes under apps/ and services/ and apps/gateway
        while IFS= read -r f; do
          if [[ "$f" == apps/gateway/* ]] || [[ "$f" == apps/gateway"" ]]; then
            svc="gateway"
          elif [[ "$f" == apps/* ]]; then
            # apps/<name>/...
            svc=$(echo "$f" | cut -d'/' -f2)
          elif [[ "$f" == services/* ]]; then
            svc=$(echo "$f" | cut -d'/' -f2)
          else
            svc=""
          fi
          if [[ -n "$svc" ]]; then
            # dedupe
            if [[ ! " ${services[@]} " =~ " ${svc} " ]]; then
              services+=("$svc")
            fi
          fi
        done <<< "$files"

        if [ ${#services[@]} -eq 0 ]; then
          echo "No services changed. Exiting." 
          # No services changed â€” emit an empty matrix output (empty string) so dispatch job is skipped
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          exit 0
        fi

        # build JSON matrix
        echo -n '{"include":[' > matrix.json
        first=true
        for s in "${services[@]}"; do
          if [ "$first" = true ]; then
            first=false
          else
            echo -n ',' >> matrix.json
          fi
          # decide path
          if [ "$s" = "gateway" ]; then
            path="apps/gateway"
          else
            path="services/$s"
          fi
          printf '{"service":"%s","path":"%s"}' "$s" "$path" >> matrix.json
        done
        echo ']}' >> matrix.json
        cat matrix.json
        # write matrix JSON as a multiline step output (clean JSON only)
        echo "matrix<<EOF" >> $GITHUB_OUTPUT
        cat matrix.json >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  preview:
    name: Preview matrix (debug)
    needs: detect
    runs-on: ubuntu-latest
    if: needs.detect.outputs.matrix != ''
    steps:
    - name: Print raw matrix JSON
      run: |
        echo "----- Raw matrix JSON -----"
        echo "${{ needs.detect.outputs.matrix }}"
        echo "---------------------------"

    - name: List matrix entries
      uses: actions/github-script@v7
      with:
        script: |
          const m = JSON.parse(process.env.MATRIX || '{}')
          console.log('Parsed matrix:')
          console.log(JSON.stringify(m, null, 2))
          if (Array.isArray(m.include)) {
            m.include.forEach(it => console.log(`service=${it.service}, path=${it.path}`))
          } else {
            console.log('No include array found in matrix')
          }
      env:
        MATRIX: ${{ needs.detect.outputs.matrix }}

  dispatch:
    name: Dispatch CI per changed service
    needs: detect
    runs-on: ubuntu-latest
    if: needs.detect.outputs.matrix != ''
    strategy:
      matrix: ${{ fromJson(needs.detect.outputs.matrix).include }}

    env:
      JAVA_VERSION: '17'
      REGISTRY: ghcr.io
      IMAGE_PREFIX: ${{ github.repository_owner }}/iwa-microservices
      AZURE_LOCATION: ${{ secrets.AZURE_LOCATION }}
      AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      AZURE_CONTAINER_ENVIRONMENT: ${{ secrets.AZURE_CONTAINER_ENVIRONMENT }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Cache Gradle per-service
      uses: actions/cache@v4
      id: gradle-cache
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: gradle-${{ runner.os }}-${{ matrix.service }}-${{ hashFiles(format('{0}/**/build.gradle', matrix.path)) }}
        restore-keys: |
          gradle-${{ runner.os }}-${{ matrix.service }}-
          gradle-${{ runner.os }}-

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: ${{ env.JAVA_VERSION }}
        cache: gradle

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    - name: Build with Gradle
      run: |
        cd "${{ matrix.path }}"
        ./gradlew build -x test

    - name: Run tests
      run: |
        cd "${{ matrix.path }}"
        ./gradlew test || true

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.service }}-build
        path: ${{ matrix.path }}/build/libs/*.jar
        retention-days: 3

    - name: Check for Dockerfile
      id: has-docker
      run: |
        if [ -f "${{ matrix.path }}/Dockerfile" ]; then
          echo "has_docker=true" >> $GITHUB_OUTPUT
        else
          echo "has_docker=false" >> $GITHUB_OUTPUT
        fi

    - name: Log in to Container Registry
      if: steps.has-docker.outputs.has_docker == 'true'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract Docker metadata
      if: steps.has-docker.outputs.has_docker == 'true'
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-

    - name: Build & push Docker image
      if: steps.has-docker.outputs.has_docker == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ matrix.path }}/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Deploy (only on main and if requested)
      if: ${{ github.ref == 'refs/heads/main' }}
      run: |
        echo "Deploying ${{ matrix.service }} to Azure Container Apps"
        pwsh -NoProfile -NonInteractive -File ./deploy/azure/deploy.ps1 \
          -ServiceParam "${{ matrix.service }}" \
          -DockerUsernameParam "${{ secrets.DOCKER_USERNAME }}" \
          -DockerPasswordParam "${{ secrets.DOCKER_PASSWORD }}" \
          -ImageTagParam "${{ github.ref_name }}"
