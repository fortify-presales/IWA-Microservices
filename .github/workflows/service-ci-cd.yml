name: Service CI/CD (reusable)

on:
  workflow_call:
    inputs:
      service:
        required: true
        type: string
      path:
        required: true
        type: string
      deploy:
        required: false
        type: boolean
        default: false
      fortify:
        required: false
        type: boolean
        default: false

jobs:
  ci:
    name: Build, Test, Scan, Deploy for ${{ inputs.service }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      security-events: write

    env:
      JAVA_VERSION: '17'
      REGISTRY: ghcr.io
      IMAGE_PREFIX: ${{ github.repository_owner }}/iwa-microservices

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # 1) When the workflow is triggered by a pull_request:
    - name: Set parent branch from PR event
      if: ${{ github.event_name == 'pull_request' }}
      run: |
        echo "PARENT_BRANCH=${{ github.event.pull_request.base.ref }}" >> $GITHUB_ENV
    # 2) When not a PR: call GitHub API to find an open PR whose head is this branch
    - name: Find parent branch via open PR (fallback)
      if: ${{ github.event_name != 'pull_request' }}
      uses: actions/github-script@v6
      id: find_parent
      with:
        script: |
          const branch = process.env.GITHUB_REF_NAME || github.context.ref.replace('refs/heads/','');
          const prs = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            head: `${context.repo.owner}:${branch}`,
          });
          if (prs.data.length) return prs.data[0].base.ref;
          return '';
    - name: Export parent branch if found
      if: ${{ steps.find_parent.outputs.result != '' }}
      run: echo "PARENT_BRANCH=${{ steps.find_parent.outputs.result }}" >> $GITHUB_ENV

    - name: Cache Gradle per-service
      uses: actions/cache@v4
      id: gradle-cache
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: gradle-${{ runner.os }}-${{ inputs.service }}-${{ hashFiles(format('{0}/**/build.gradle', inputs.path)) }}
        restore-keys: |
          gradle-${{ runner.os }}-${{ inputs.service }}-
          gradle-${{ runner.os }}-

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: ${{ env.JAVA_VERSION }}
        cache: gradle

    - name: Build with Gradle
      run: |
        cd "${{ inputs.path }}"
        ./gradlew build -x test

    - name: Run tests
      run: |
        cd "${{ inputs.path }}"
        ./gradlew test || true

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.service }}-build
        path: ${{ inputs.path }}/build/libs/*.jar
        retention-days: 3

    - name: Check for Dockerfile
      id: has-docker
      run: |
        if [ -f "${{ inputs.path }}/Dockerfile" ]; then
          echo "has_docker=true" >> $GITHUB_OUTPUT
        else
          echo "has_docker=false" >> $GITHUB_OUTPUT
        fi

    - name: Log in to Container Registry
      if: steps.has-docker.outputs.has_docker == 'true'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract Docker metadata
      if: steps.has-docker.outputs.has_docker == 'true'
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ inputs.service }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-

    - name: Build & push Docker image
      if: steps.has-docker.outputs.has_docker == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ inputs.path }}/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Run Fortify Security scan
      if: ${{ inputs.fortify == true }}
      #uses: fortify/github-action@v3
      uses: fortify/github-action@feat/fcli-ci
      env:
        SOURCE_DIR: ${{ inputs.path }}
        FCLI_BOOTSTRAP_URL: https://github.com/fortify/fcli/releases/download/dev_v3.x/fcli-linux.tgz
        FOD_URL: ${{ vars.FOD_URL }}
        FOD_CLIENT_ID: ${{ secrets.FOD_CLIENT_ID }}
        FOD_CLIENT_SECRET: ${{ secrets.FOD_CLIENT_SECRET }}
        FOD_RELEASE: "${{ vars.FOD_APPLICATION }}${{ vars.FOD_APP_NAME_POSTFIX }}:${{ inputs.service }}:${{ github.ref_name }}"
        DO_SETUP: true
        SETUP_EXTRA_OPTS: ${{ format('--copy-from "{0}{1}:{2}:{3}" --sdlc-status Development --app-owner {4} --assessment-type "{5}"', vars.FOD_APPLICATION, vars.FOD_APP_NAME_POSTFIX, inputs.service, env.PARENT_BRANCH, vars.FOD_DEFAULT_OWNER, vars.FOD_DEFAULT_ASSESSMENT_TYPE) }}
        PACKAGE_EXTRA_OPTS: -bt gradle -bf build.gradle -bc "clean build -x test" -oss
        DO_SAST_SCAN: true
        DO_RELEASE_SUMMARY: true
        DO_CHECK_POLICY: false # set to true to enforce policy check
        DO_PR_COMMENT: ${{ github.event_name == 'pull_request' }}

    - name: Azure Login
      if: ${{ inputs.deploy == true && github.ref == 'refs/heads/main' }}
      uses: azure/login@v1
      with:
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy (only on main and if requested)
      if: ${{ inputs.deploy == true && github.ref == 'refs/heads/main' }}
      run: |
        echo "Deploying ${{ inputs.service }} to Azure Container Apps"
        pwsh -NoProfile -NonInteractive -File ./deploy/azure/deploy.ps1 \
          -ServiceParam "${{ inputs.service }}" \
          -DockerUsernameParam "${{ secrets.DOCKER_USERNAME }}" \
          -DockerPasswordParam "${{ secrets.DOCKER_PASSWORD }}" \
          -ImageTagParam "${{ github.ref_name }}"
      env:
        AZURE_LOCATION: ${{ secrets.AZURE_LOCATION }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
        AZURE_CONTAINER_ENVIRONMENT: ${{ secrets.AZURE_CONTAINER_ENVIRONMENT }}
        # The deploy script will read Docker creds from the passed params; ensure they exist in repository secrets
